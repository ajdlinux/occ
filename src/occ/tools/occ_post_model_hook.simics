################################################################################
# post_model_hook.simics
# This file is used to run a set of commands on the simics console after
# modules have loaded.

$occc = [0]
$proc_chip = [0]

if not (lookup-file ../src/occc/405/occ/tools/occ_simics_gen_lists.py ){
  #run-python-file /gsa/ausgsa/projects/o/occfw/public/simics/scripts/cc_simics_gen_lists.py
  
  #----------------------------------------------------------
  # Figure out what OCCs are out there & create a list
  #----------------------------------------------------------
  $occc[0]=0; $b=0; foreach $c in (get-object-list -all occ_simple) {$occc[$b] = $c; $b = $b + 1}
  #----------------------------------------------------------
  # Figure out what CEC-chips are out there & create a list
  #----------------------------------------------------------
  $proc_chip[0]=0; $f=0; foreach $g in (get-object-list -all cec-chip) {$proc_chip[$f] = $g; $f = $f + 1}
} else {
  run-python-file ../src/occc/405/occ/tools/occ_simics_gen_lists.py
}

#----------------------------------------------------------
# Figure out what OCCs are out there & create a list
#----------------------------------------------------------
#$occc[0]=0; $b=0; foreach $c in (get-object-list -all occ_simple) {$occc[$b] = $c; $b = $b + 1}

#----------------------------------------------------------
# Figure out what PSSs are out there & create a list
#----------------------------------------------------------
$apss = [0]
$apss[0]=0; $d=0; foreach $e in (get-object-list -all apss_device) {$apss[$d] = $e; $d = $d + 1}
#$dpss[0]=0; $f=0; foreach $g in (get-object-list -all dpss_device) {$dpss[$f] = $g; $f = $f + 1}

#----------------------------------------------------------
# Figure out what CEC-chips are out there & create a list
#----------------------------------------------------------
#$proc_chip[0]=0; $f=0; foreach $g in (get-object-list -all cec-chip) {$proc_chip[$f] = $g; $f = $f + 1}

#----------------------------------------------------------
# ChipId/NodeId Lists for OCC Alone Model
#----------------------------------------------------------
$occChipId_murano    = []
$occChipId_murano[0] = 0x0000000000000000;   # NodeID=0, ChipID=0
$occChipId_murano[1] = 0x0000000000040000;   # NodeID=0, ChipID=1
$occChipId_murano[2] = 0x0000000000200000;   # NodeID=1, ChipID=0
$occChipId_murano[3] = 0x0000000000240000;   # NodeID=1, ChipID=1
$occChipId_murano[4] = 0x0000000000400000;   # NodeID=2, ChipID=0
$occChipId_murano[5] = 0x0000000000440000;   # NodeID=2, ChipID=1
$occChipId_murano[6] = 0x0000000000600000;   # NodeID=3, ChipID=0
$occChipId_murano[7] = 0x0000000000640000;   # NodeID=3, ChipID=1

$occChipId_venice    = []
$occChipId_venice[0] = 0x0000000000000000;   # NodeID=0, ChipID=0
$occChipId_venice[1] = 0x0000000000040000;   # NodeID=0, ChipID=1
$occChipId_venice[2] = 0x0000000000080000;   # NodeID=0, ChipID=2
$occChipId_venice[3] = 0x00000000000C0000;   # NodeID=0, ChipID=3
$occChipId_venice[4] = 0x0000000000100000;   # NodeID=0, ChipID=4
$occChipId_venice[5] = 0x0000000000140000;   # NodeID=0, ChipID=5
$occChipId_venice[6] = 0x0000000000180000;   # NodeID=0, ChipID=6
$occChipId_venice[7] = 0x00000000001C0000;   # NodeID=0, ChipID=7


#----------------------------------------------------------
# Set up path to OCC image
#----------------------------------------------------------
$occ_image = "../obj/ppc/occc/405/image.bin"
if not (lookup-file $occ_image  ){
  echo "Using GNUmake image"
  $occ_image = "../src/occc/405/image.bin"
}else{
  echo "Using ODEmake image"
}


#----------------------------------------------------------
# Create symbol table for occ application using sandbox or backing build
#----------------------------------------------------------
@occoutfile = "/../obj/ppc/occc/405/occ/occ.out"
@occsb = os.getenv("sb")
@cli.run_command("$occsb = " + occsb + occoutfile)
@occbb = os.getenv("bb")
@cli.run_command("$occbb = " + occbb + "/src" + occoutfile)

# Create symbol table - first look in $sb, then $bb, then gnumake location
if not (lookup-file $occsb  ){
    echo "Cannot find OCC Symbols file in Sandbox"

    if not (lookup-file $occbb)  {
        echo "Cannot find OCC Symbols file in Backing Build"

        @cli.run_command("$occsb = " + occsb + "/occc/405/occ/occ.out")
        if not (lookup-file $occsb)  {
           echo "Cannot find OCC Symbols file in src/ tree"
        }else{
           echo "Loaded symbol file from src/occ/occ.out"
          new-symtable occst $occsb
        }
    }else{
        echo "Loaded symbol table from $bb/obj/ppc/occc/405/occ/occ.out"
        new-symtable occst $occbb
    }
}else{
    echo "Loaded symbol table from $sb/obj/ppc/occc/405/occ/occ.out"
    new-symtable occst $occsb
}


#----------------------------------------------------------
# Create symbol table for occ Bootloader using sandbox or backing build
#----------------------------------------------------------
@btoutfile = "/../obj/ppc/occc/405/occBootLoader/bootloader.out"
@cli.run_command("$occsb = " + occsb + btoutfile)
@cli.run_command("$occbb = " + occbb + "/src" + btoutfile)

# Create symbol table - first look in $sb, then $bb, then gnumake location
if not (lookup-file $occsb  ){
    echo "Cannot find Bootloader Symbols file in Sandbox" 
    if not (lookup-file $occbb)  {
        echo "Cannot find Bootloader Symbols file in Backing Build"
 
        @cli.run_command("$occsb = " + occsb + "/occc/405/occBootLoader/bootloader.out")
        if not (lookup-file $occsb)  {
           echo "Cannot find Bootloader Symbols file src/ tree"
        }else{
          echo "Loaded symbol file from src/occBootLoader/bootloader.out"
          occst.load-symbols $occsb
        }
    }else{
        echo "Loaded symbol table from $bb/obj/ppc/occc/405/occBootLoader/bootloader.out"
        occst.load-symbols $occbb
    }
}else{
    echo "Loaded symbol table from $sb/obj/ppc/occc/405/occBootLoader/bootloader.out"
    occst.load-symbols $occsb
}


#----------------------------------------------------------
# Loop through all present OCCs, setting them all to the 
# same initial settings
#----------------------------------------------------------
while $b {
  $b -= 1

  echo " "
  echo "-------------------------------------------------------- "
  echo "Loading & configuring:  "
  echo $occc[$b]
  echo "-------------------------------------------------------- "

  # Set up symbol table for each OCC
  @occ_path = cli.quiet_run_command("echo $occc[$b]")
  @cli.run_command("@conf." + occ_path[1].rstrip('\n') + ".cpu.current_context.symtable = conf.occst")

  # Load OCC image
  # $occc[$b].pob_space.load-file ../src/image.bin

  # Load OCC image
  $alone = p8Proc0.OccComplexSlot->isStandalone
  if $alone == 0 {
    echo "Loading OCC image into phys_mem"
    proc_venicechip_cmp0.phys_mem.load-file $occ_image 0x400000
    $occc[$b].pba->pba_slvctl0 = 0x87001E0000000000   # OCC HOMER Image
    $occc[$b].pba->pba_barmsk0 = 0x0000000000300000   # OCC HOMER Image
    $occc[$b].pba->pba_bar0    = 0x0000000000400000   # OCC HOMER Image
  } else {
    echo "Alone: Loading into fake phys_mem"
    backplane0.phys_mem.load-file $occ_image 0x400000
    $occc[$b].pba->pba_slvctl0 = 0x87001E0000000000   # OCC HOMER Image
    $occc[$b].pba->pba_barmsk0 = 0x0000000000300000   # OCC HOMER Image
    $occc[$b].pba->pba_bar0    = 0x0000000000400000   # OCC HOMER Image
  }

  # Set PBA BAR register - simics 04/04/2012 and newer
  $occc[$b].pba->pba_mode    = 0x00E03A9000000000
  $occc[$b].pba->pba_slvctl3 = 0xD7005E4000000000   # OCC Common
  $occc[$b].pba->pba_slvctl2 = 0xC7005E4000000000   # PORE-SLW
  $occc[$b].pba->pba_slvctl1 = 0xE6005E4000000000   # Centaur
  $occc[$b].pba->pba_bar1    = 0x0003e00000000000   # Centaur
  $occc[$b].pba->pba_barmsk1 =      0x1fffff00000   # Centaur
  $occc[$b].pba->pba_bar3    = 0x0000000008000000   # OCC Common Image
  $occc[$b].pba->pba_barmsk3 =      0x00000700000   # OCC Common Image

  # Set OCB registers until we are always talking via TMGT/HWSV
  $occc[$b].ocb->ocb_ocbar0  = 0xffff600000000000
  $occc[$b].ocb->ocb_ocbcsr0 = 0x0800000000000000
  $occc[$b].ocb->ocb_ocbcsr1 = 0x0c00000000000000
  $occc[$b].ocb->ocb_ocbar1  = 0xffff600000000000

  # Set CPI to be more accurate.  Simics defaults to a CPI = 1, but it
  # is more likely with our workload that we will have a CPI ~= 3.  Simics
  # only allows certain step rates, so we will end up with a CPI of 2.9767
  # Step Rate = IPC = 1/CPI
  $occc[$b].cpu.set-step-rate "43/128"
  
  # Set branch to address 64(0x40) and place this branch at 0xFFFFFFFC.
  $occc[$b].oci_space.set 0xfffffffc 0x48000042
 
  # ---------------------------------------------------------
  # Temporary Workarounds
  # --------------------------------------------------------- 
  echo " "
  echo "-------------------------------------------------------- "
  echo "Applying Workarounds to Enable OCC"
  echo "-------------------------------------------------------- "

  # In the beginning Scott Prather created the simics model and the occ.  
  # Now the occ was formless and empty, [and didn't have all the inits
  # that would happen on a real system.]
  # And Scott said, "Let there be clocks": and there was clocks. 
  # Scott saw that clocks were good, and Scott divided clocks from [simics 
  # init into this seperate initialization.]
  $proc_chip[$b].regwrite LOGIC 0xFF000001 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50000 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50001 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50002 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50003 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50004 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50005 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50006 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50007 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50008 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50009 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50010 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50011 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50012 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50013 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50014 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50015 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50016 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC50019 FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC5001A FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC5001B FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC5001C FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC5001D FFFFFFFF_FFFFFFFF 64
  $proc_chip[$b].regwrite LOGIC 0xFFC5001E FFFFFFFF_FFFFFFFF 64

  # FW588165 : PHYP scom to OCC targeting invalid address 0x40020
  $occc[$b].pcb_space.add-map $occc[$b].ocb:pib 0x00040020 0x1

  # Simics Crash when hitting PBAX operations
  #@cli.run_command("@conf." + occ_path[1].rstrip('\n') + ".pba.pbax_connector=conf.p8Proc0.OccComplexSlot.pbax_router")
  
  if $alone == 0 {
    echo ""
  } else {
    echo "OCC Alone Workaround: Set ChipId & NodeId (Murano)"
    $occc[$b].pib_master->address = 0x01000000
    $occc[$b].pib_master->data = $occChipId_murano[$b]
  }
}

# ---------------------------------------------------------
# APSS settings
# ---------------------------------------------------------
$apss[0]->adc_channel_val        = [ 0x2da,  # [0]: Memory 1              --  90.000 W
                                     0x302,  # [1]: Memory 2              --  95.000 W
                                     0x3cd,  # [2]: Proc1 Vdd             -- 120.000 W
                                     0x3bd,  # [3]: Proc2 Vdd             -- 118.000 W
                                     0x659,  # [4]: Proc 1 Vcs/Vio/Vpcie  -- 100.000 W
                                     0x6aa,  # [5]: Proc 2 Vcs/Vio/Vpcie  -- 105.000 W
                                     0x592,  # [6]: Storage/Media 1       --  80.000 W
                                     0x5eb,  # [7]: Storage/Media 2       --  85.000 W
                                     0x000,  # [8]: Remote GND            --   0.000 V
                                     0xecb,  # [9]: 12V Voltage Sense     --  12.300 V
                                     0x1bd,  # [a]: IO 1                  --  25.000 W
                                     0x1cf,  # [b]: IO 2                  --  26.000 W
                                     0x1e1,  # [c]: IO 3                  --  27.000 W
                                     0x10b,  # [d]: Fans 1                --  15.000 W
                                     0x0d5,  # [e]: Fans 2                --  12.000 W
                                     0x001]  # [f]: Unused                --   0.000  
#                                                                   ----------
#                                             Total                  -- 898.000 W


# ---------------------------------------------------------
# Vpm - Uncomment lines below to run Vpm
# ---------------------------------------------------------
#@occoutfile = "/../simics/vpm/vpxP7"
#@occsb = os.getenv("sb")
#@cli.run_command("!" + occsb + occoutfile)

@poolsys = os.getenv("DISPLAY")
#@cli.run_command("Vpm.run-spec spec = square vpxServer = " + poolsys.split( ':',1)[0])
#Vpm.enable-vpm


# ---------------------------------------------------------
# Misc Simics settings
# ---------------------------------------------------------
output-radix 16     # output in hex

# ---------------------------------------------------------
# Run python script(s) to enable some OCC Simics Commands
# ---------------------------------------------------------
echo " "
echo "-------------------------------------------------------- "
echo "Load OCC Developer Debug Scripts"
echo "-------------------------------------------------------- "
if not (lookup-file ../src/occc/405/occ/tools/occ_simics_debug.py ){
    echo "Load Scripts from GSA"
    run-python-file /gsa/ausgsa/projects/o/occfw/public/simics/scripts/occ_simics_debug.py  # hsym, h64sym, h64attr
    run-python-file /gsa/ausgsa/projects/o/occfw/public/simics/scripts/occ_amec_sensors.py  # amec commands
    run-python-file /gsa/ausgsa/projects/o/occfw/public/simics/scripts/occ_fsp_fakeout.py   # tmgt commands
    run-python-file /gsa/ausgsa/projects/o/occfw/public/simics/scripts/occ_gdb.py           # gdb/ddd commands
}else{
    echo "Load Scripts from Sandbox"
    run-python-file ../src/occc/405/occ/tools/occ_simics_debug.py  # hsym, h64sym, h64attr
    run-python-file ../src/occc/405/occ/tools/occ_amec_sensors.py  # amec commands
    run-python-file ../src/occc/405/occ/tools/occ_fsp_fakeout.py   # tmgt commands
    run-python-file ../src/occc/405/occ/tools/occ_gdb.py           # gdb/ddd commands
}

# ---------------------------------------------------------
# Set up Centaur/MCS so OCC can access Centaur
# ---------------------------------------------------------
echo " "
echo "-------------------------------------------------------- "
echo "Set up Centaur/MCS so OCC can access Centaur"
echo "-------------------------------------------------------- "
#putscom 0x2011802 0x83e0000000000000  # Centaur 0 -- Venice Only
#putscom 0x2011882 0x83e0200000000000  # Centaur 1 -- Venice Only
#putscom 0x2011902 0x83e0400000000000  # Centaur 2 -- Venice Only
#putscom 0x2011982 0x83e0600000000000  # Centaur 3 -- Venice Only
##putscom 0x2011c02 0x83e0800000000000  # Centaur 4
##putscom 0x2011c82 0x83e0a00000000000  # Centaur 5
##putscom 0x2011d02 0x83e0c00000000000  # Centaur 6
##putscom 0x2011d82 0x83e0e00000000000  # Centaur 7


# ---------------------------------------------------------
# Enabling Magic Breakpoint to help with development debug
# ---------------------------------------------------------
echo " "
echo "-------------------------------------------------------- "
echo "Enabling Simics Magic Breakpoint for OCC developer debug "
echo "     To Disable:     disable-magic-breakpoint"
echo "     To Start GDB:   occ-gdb-start <occnum>"
echo "-------------------------------------------------------- "
echo " "
enable-magic-breakpoint

